define endian=big;

define alignment=2;

define space ram type=ram_space size=2 default;
define space register type=register_space size=2;

define register offset=0xf size=2 [r0 r1 r2 r3 r4 r5 fp sp sr pc];

define register offset=0x100 size=1 [cp dp ep tp br];

# SR Flags
@define T_FLAG   "sr[15,1]"
@define I0_FLAG  "sr[8,1]"
@define I1_FLAG  "sr[9,1]"
@define I2_FLAG  "sr[10,1]"
@define N_FLAG   "sr[3,1]"
@define Z_FLAG   "sr[2,1]"
@define V_FLAG   "sr[1,1]"
@define C_FLAG   "sr[0,1]"



# Immediate Data (Literal operation)



define token instr32(32)
	opcode1_32bit = (0,7)
	address_24bit = (8,31)
	address_16bit = (8,23)
	opcode2_32bit = (24,31)
;

define token instr8(8)
	opcode_byte = (0,7)
;

define token instr16(16)
	opcode_wholeword = (0,15)
	opcode_firstbyte = (0,7)
	immediate_value_byte = (8,15)
	opcode_00_04 = (0,4)
	register_05_07 = (5,7)
	opcode_08_15 = (8,15)
;



#imm8: "#"k8	is k8										{ export *[const]:1 k8; }
#imm16: "#"k16	is k16										{ export *[const]:2 k16; }


#bit: "#"b3		is b3									{ export *[const]:1 b3; }

macro push(val) {
	*[register]:1 sp = val;
	sp = sp-2;
}
	
macro pop(val) {
	sp = sp + 2;
	val = *[register]:1 sp;
}


attach variables [  register_05_07 ] [
 r0 r1 r2 r3 r4 r5 _ _
];

define pcodeop sleep;

:sleep is opcode_byte=0b0011010 {
	sleep();
}

:pjsr    @address_24bit  is opcode1_32bit=0x03 & address_24bit
{
    call [r0];
}

:jsr    @address_24bit  is opcode1_32bit=0x01 & address_24bit
{
    call [r0];
}

:prts   is opcode_wholeword=0x1119
{

		return [r0];
}

:link  is opcode_firstbyte=0x17 & immediate_value_byte
{
		r0 = r0;
}

:nop is opcode_byte=0x0 
{
	r0 = r0;
}


:extu is opcode_00_04=0b10100 & register_05_07 & opcode_08_15=0b00010010
{
		register_05_07 = 0;
}

:unlk is opcode_byte=0x0f
{
	sp = fp;
	pop(sp);
	
}